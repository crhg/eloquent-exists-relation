<?php
/**
 * Created by IntelliJ IDEA.
 * User: matsui
 * Date: 2018/11/08
 * Time: 13:45
 */
declare(strict_types=1);

namespace Crhg\EloquentExistsRelation\Providers;


use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Relations\Relation;
use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Str;

/**
 * XXX: To deal with PhpStorm warnings
 * @property \Illuminate\Database\Query\Builder $query
 * @method parseWithRelations(array $relations)
 * @method selectExists($query, $as)
 * @method forSubQuery()
 * @method parseSubSelect($query)
 * @method createSub($query)
 * @mixin Builder
 */
class EloquentExistsRelationProvider extends ServiceProvider
{
    public function boot(): void
    {
        $this->setupWithExists();
    }

    public function register(): void
    {
    }

    protected function setupWithExists(): void
    {
        /**
         * Add subselect queries to check the existence of the relations.
         *
         * @param  mixed  $relations
         * @return $this
         */
        Builder::macro('withExists',
            function ($relations): Builder {

                if (empty($relations)) {
                    return $this;
                }

                if ($this->query->columns === null) {
                    $this->query->select([$this->query->from . '.*']);
                }

                $relations = \is_array($relations) ? $relations : \func_get_args();

                foreach ($this->parseWithRelations($relations) as $name => $constraints) {
                    // First we will determine if the name has been aliased using an "as" clause on the name
                    // and if it has we will extract the actual relationship name and the desired name of
                    // the resulting column. This allows multiple counts on the same relationship name.
                    $segments = explode(' ', $name);

                    unset($alias);

                    if (\count($segments) === 3 && Str::lower($segments[1]) === 'as') {
                        [$name, , $alias] = $segments;
                    }

                    /** @var Relation $relation */
                    $relation = $this->getRelationWithoutConstraints($name);

                    // Here we will get the relationship count query and prepare to add it to the main query
                    // as a sub-select. First, we'll get the "has" query and use that to get the relation
                    // count query. We will normalize the relation name then append _count as the name.

                    $query = $relation->getRelationExistenceQuery(
                        $relation->getRelated()->newQuery(),
                        $this
                    );

                    $query->callScope($constraints);

                    $query->mergeConstraintsFrom($relation->getQuery());

                    // Finally we will add the proper result column alias to the query and run the subselect
                    // statement against the query builder. Then we will return the builder instance back
                    // to the developer for further constraint chaining that needs to take place on it.
                    $column = $alias ?? Str::snake($name . '_exists');

                    $this->selectExists($query->toBase(), $column);
                }

                return $this;

            });

        \Illuminate\Database\Query\Builder::macro('selectExists', function ($query, $as) {

            // If the given query is a Closure, we will execute it while passing in a new
            // query instance to the Closure. This will give the developer a chance to
            // format and work with the query before we cast it to a raw SQL string.
            if ($query instanceof \Closure) {
                $callback = $query;

                $callback($query = $this->forSubQuery());
            }

            // Here, we will parse this query into an SQL string and an array of bindings
            // so we can add it to the query builder using the selectRaw method so the
            // query is included in the real SQL generated by this builder instance.
            [$query, $bindings] = $this->parseSubSelect($query);

            return $this->selectRaw(
                'EXISTS (' . $query . ') as ' . $this->grammar->wrap($as), $bindings
            );

        });
    }
}
